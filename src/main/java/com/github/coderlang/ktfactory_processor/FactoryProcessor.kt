package com.github.coderlang.ktfactory_processor

import com.github.coderlang.ktfactory.annotation.Factory
import org.jetbrains.annotations.NotNull
import java.io.OutputStreamWriter
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.Messager
import javax.annotation.processing.ProcessingEnvironment
import javax.annotation.processing.RoundEnvironment
import javax.lang.model.element.AnnotationMirror
import javax.lang.model.element.AnnotationValue
import javax.lang.model.element.Element
import javax.lang.model.element.TypeElement
import javax.tools.Diagnostic
import kotlin.io.path.Path

private fun isJavaFile(element: TypeElement): Boolean {
	val metaDataClass = Class.forName("kotlin.Metadata").asSubclass(Annotation::class.java)
	return element.getAnnotation(metaDataClass) == null
}

private fun isNotNull(element: Element): Boolean {
	return element.getAnnotation(NotNull::class.java) != null || element.asType().kind.isPrimitive
}

class FactoryProcessor : AbstractProcessor() {
	internal var logger: Logger = Logger(object : Messager {
		override fun printMessage(p0: Diagnostic.Kind?, p1: CharSequence?) {}
		override fun printMessage(p0: Diagnostic.Kind?, p1: CharSequence?, p2: Element?) {}
		override fun printMessage(p0: Diagnostic.Kind?, p1: CharSequence?, p2: Element?, p3: AnnotationMirror?) {}
		override fun printMessage(p0: Diagnostic.Kind?, p1: CharSequence?, p2: Element?, p3: AnnotationMirror?, p4: AnnotationValue?) {}
	})
	internal var outDirectory = ""

	override fun init(processingEnv: ProcessingEnvironment) {
		super.init(processingEnv)
		logger = Logger(processingEnv.messager)
		outDirectory = processingEnv.options["kapt.kotlin.generated"]!!
	}

	override fun getSupportedAnnotationTypes(): Set<String> {
		val annotations: MutableSet<String> = LinkedHashSet()
		annotations.add(Factory::class.qualifiedName!!)
		return annotations
	}

	override fun process(
		annotations: MutableSet<out TypeElement>,
		roundEnv: RoundEnvironment
	): Boolean {
		if (annotations.isEmpty()) {
			processingEnv.messager.printMessage(Diagnostic.Kind.NOTE, "hello: annotations is empty.")
			return true
		}

		val builder = StringBuilder()
		for (ee in roundEnv.getElementsAnnotatedWith(Factory::class.java)) {
			if (isJavaFile(ee as TypeElement)) continue
			val annotation = ee.getAnnotation(Factory::class.java)
			builder.append("""
			"${annotation.factory}${annotation.key}" to "$ee",
			""".trimIndent())
			builder.append("\n")
		}

		val factoryContainer = """
			package com.github.coderlang.ktfactory
			
			// This file is generated by ktfactory_processor. DO NOT edit it!
      
			class FactoryContainerImpl : FactoryContainer() {
				override val AllFactory: Map<String, String> = 
					mapOf(
						${builder.toString().align("         ")}
					)
			}
		""".trimIndent()
		write(outDirectory, "com.github.coderlang.ktfactory", "FactoryContainerImpl", factoryContainer)
		return true
	}
}

fun write(outDirectory: String, packageName: String, fileName: String, fileContent: String) {
	var outputDirectory = Path(outDirectory)
	if (packageName.isNotEmpty()) {
		for (packageComponent in packageName.split('.').dropLastWhile { it.isEmpty() }) {
			outputDirectory = outputDirectory.resolve(packageComponent)
		}
	}

	Files.createDirectories(outputDirectory)

	val outputPath = outputDirectory.resolve("$fileName.kt")
	val writer = OutputStreamWriter(Files.newOutputStream(outputPath), StandardCharsets.UTF_8)
	writer.write(fileContent)
	writer.flush()
}